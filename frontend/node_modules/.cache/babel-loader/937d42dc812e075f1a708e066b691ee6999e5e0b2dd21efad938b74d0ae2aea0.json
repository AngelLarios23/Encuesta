{"ast":null,"code":"/**\n * Expose `pathToRegexp`.\n */\n\nmodule.exports = pathToRegexp;\n\n/**\n * Match matching groups in a regular expression.\n */\nvar MATCHING_GROUP_REGEXP = /\\\\.|\\((?:\\?<(.*?)>)?(?!\\?)/g;\n\n/**\n * Normalize the given path string,\n * returning a regular expression.\n *\n * An empty array should be passed,\n * which will contain the placeholder\n * key names. For example \"/user/:id\" will\n * then contain [\"id\"].\n *\n * @param  {String|RegExp|Array} path\n * @param  {Array} keys\n * @param  {Object} options\n * @return {RegExp}\n * @api private\n */\n\nfunction pathToRegexp(path, keys, options) {\n  options = options || {};\n  keys = keys || [];\n  var strict = options.strict;\n  var end = options.end !== false;\n  var flags = options.sensitive ? '' : 'i';\n  var lookahead = options.lookahead !== false;\n  var extraOffset = 0;\n  var keysOffset = keys.length;\n  var i = 0;\n  var name = 0;\n  var pos = 0;\n  var backtrack = '';\n  var m;\n  if (path instanceof RegExp) {\n    while (m = MATCHING_GROUP_REGEXP.exec(path.source)) {\n      if (m[0][0] === '\\\\') continue;\n      keys.push({\n        name: m[1] || name++,\n        optional: false,\n        offset: m.index\n      });\n    }\n    return path;\n  }\n  if (Array.isArray(path)) {\n    // Map array parts into regexps and return their source. We also pass\n    // the same keys and options instance into every generation to get\n    // consistent matching groups before we join the sources together.\n    path = path.map(function (value) {\n      return pathToRegexp(value, keys, options).source;\n    });\n    return new RegExp(path.join('|'), flags);\n  }\n  path = path.replace(/\\\\.|(\\/)?(\\.)?:(\\w+)(\\(.*?\\))?(\\*)?(\\?)?|[.*]|\\/\\(/g, function (match, slash, format, key, capture, star, optional, offset) {\n    pos = offset + match.length;\n    if (match[0] === '\\\\') {\n      backtrack += match;\n      return match;\n    }\n    if (match === '.') {\n      backtrack += '\\\\.';\n      extraOffset += 1;\n      return '\\\\.';\n    }\n    backtrack = slash || format ? '' : path.slice(pos, offset);\n    if (match === '*') {\n      extraOffset += 3;\n      return '(.*)';\n    }\n    if (match === '/(') {\n      backtrack += '/';\n      extraOffset += 2;\n      return '/(?:';\n    }\n    slash = slash || '';\n    format = format ? '\\\\.' : '';\n    optional = optional || '';\n    capture = capture ? capture.replace(/\\\\.|\\*/, function (m) {\n      return m === '*' ? '(.*)' : m;\n    }) : backtrack ? '((?:(?!/|' + backtrack + ').)+?)' : '([^/' + format + ']+?)';\n    keys.push({\n      name: key,\n      optional: !!optional,\n      offset: offset + extraOffset\n    });\n    var result = '(?:' + format + slash + capture + (star ? '((?:[/' + format + '].+?)?)' : '') + ')' + optional;\n    extraOffset += result.length - match.length;\n    return result;\n  });\n\n  // This is a workaround for handling unnamed matching groups.\n  while (m = MATCHING_GROUP_REGEXP.exec(path)) {\n    if (m[0][0] === '\\\\') continue;\n    if (keysOffset + i === keys.length || keys[keysOffset + i].offset > m.index) {\n      keys.splice(keysOffset + i, 0, {\n        name: name++,\n        // Unnamed matching groups must be consistently linear.\n        optional: false,\n        offset: m.index\n      });\n    }\n    i++;\n  }\n  path += strict ? '' : path[path.length - 1] === '/' ? '?' : '/?';\n\n  // If the path is non-ending, match until the end or a slash.\n  if (end) {\n    path += '$';\n  } else if (path[path.length - 1] !== '/') {\n    path += lookahead ? '(?=/|$)' : '(?:/|$)';\n  }\n  return new RegExp('^' + path, flags);\n}\n;","map":{"version":3,"names":["module","exports","pathToRegexp","MATCHING_GROUP_REGEXP","path","keys","options","strict","end","flags","sensitive","lookahead","extraOffset","keysOffset","length","i","name","pos","backtrack","m","RegExp","exec","source","push","optional","offset","index","Array","isArray","map","value","join","replace","match","slash","format","key","capture","star","slice","result","splice"],"sources":["C:/Users/PC/Documents/4 cuatrimestre/Aplicacion web/ProyectoEncuetas/Encuesta4.1/Encuesta/frontend/node_modules/path-to-regexp/index.js"],"sourcesContent":["/**\n * Expose `pathToRegexp`.\n */\n\nmodule.exports = pathToRegexp;\n\n/**\n * Match matching groups in a regular expression.\n */\nvar MATCHING_GROUP_REGEXP = /\\\\.|\\((?:\\?<(.*?)>)?(?!\\?)/g;\n\n/**\n * Normalize the given path string,\n * returning a regular expression.\n *\n * An empty array should be passed,\n * which will contain the placeholder\n * key names. For example \"/user/:id\" will\n * then contain [\"id\"].\n *\n * @param  {String|RegExp|Array} path\n * @param  {Array} keys\n * @param  {Object} options\n * @return {RegExp}\n * @api private\n */\n\nfunction pathToRegexp(path, keys, options) {\n  options = options || {};\n  keys = keys || [];\n  var strict = options.strict;\n  var end = options.end !== false;\n  var flags = options.sensitive ? '' : 'i';\n  var lookahead = options.lookahead !== false;\n  var extraOffset = 0;\n  var keysOffset = keys.length;\n  var i = 0;\n  var name = 0;\n  var pos = 0;\n  var backtrack = '';\n  var m;\n\n  if (path instanceof RegExp) {\n    while (m = MATCHING_GROUP_REGEXP.exec(path.source)) {\n      if (m[0][0] === '\\\\') continue;\n\n      keys.push({\n        name: m[1] || name++,\n        optional: false,\n        offset: m.index\n      });\n    }\n\n    return path;\n  }\n\n  if (Array.isArray(path)) {\n    // Map array parts into regexps and return their source. We also pass\n    // the same keys and options instance into every generation to get\n    // consistent matching groups before we join the sources together.\n    path = path.map(function (value) {\n      return pathToRegexp(value, keys, options).source;\n    });\n\n    return new RegExp(path.join('|'), flags);\n  }\n\n  path = path.replace(\n    /\\\\.|(\\/)?(\\.)?:(\\w+)(\\(.*?\\))?(\\*)?(\\?)?|[.*]|\\/\\(/g,\n    function (match, slash, format, key, capture, star, optional, offset) {\n      pos = offset + match.length;\n\n      if (match[0] === '\\\\') {\n        backtrack += match;\n        return match;\n      }\n\n      if (match === '.') {\n        backtrack += '\\\\.';\n        extraOffset += 1;\n        return '\\\\.';\n      }\n\n      backtrack = slash || format ? '' : path.slice(pos, offset);\n\n      if (match === '*') {\n        extraOffset += 3;\n        return '(.*)';\n      }\n\n      if (match === '/(') {\n        backtrack += '/';\n        extraOffset += 2;\n        return '/(?:';\n      }\n\n      slash = slash || '';\n      format = format ? '\\\\.' : '';\n      optional = optional || '';\n      capture = capture ?\n        capture.replace(/\\\\.|\\*/, function (m) { return m === '*' ? '(.*)' : m; }) :\n        (backtrack ? '((?:(?!/|' + backtrack + ').)+?)' : '([^/' + format + ']+?)');\n\n      keys.push({\n        name: key,\n        optional: !!optional,\n        offset: offset + extraOffset\n      });\n\n      var result = '(?:'\n        + format + slash + capture\n        + (star ? '((?:[/' + format + '].+?)?)' : '')\n        + ')'\n        + optional;\n\n      extraOffset += result.length - match.length;\n\n      return result;\n    });\n\n  // This is a workaround for handling unnamed matching groups.\n  while (m = MATCHING_GROUP_REGEXP.exec(path)) {\n    if (m[0][0] === '\\\\') continue;\n\n    if (keysOffset + i === keys.length || keys[keysOffset + i].offset > m.index) {\n      keys.splice(keysOffset + i, 0, {\n        name: name++, // Unnamed matching groups must be consistently linear.\n        optional: false,\n        offset: m.index\n      });\n    }\n\n    i++;\n  }\n\n  path += strict ? '' : path[path.length - 1] === '/' ? '?' : '/?';\n\n  // If the path is non-ending, match until the end or a slash.\n  if (end) {\n    path += '$';\n  } else if (path[path.length - 1] !== '/') {\n    path += lookahead ? '(?=/|$)' : '(?:/|$)';\n  }\n\n  return new RegExp('^' + path, flags);\n};\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}